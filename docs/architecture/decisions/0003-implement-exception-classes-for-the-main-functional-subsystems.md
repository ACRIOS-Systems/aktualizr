# 3. Implement exception classes for the main functional subsystems

Date: 2019-09-13

## Status

Accepted

## Context

We need a consistent exceptions class structure, to allow users of libaktualizr easily understand the source and type of failure.

## Decision

Concider the following diagram:
![libaktualizr structure](https://github.com/advancedtelematic/aktualizr/blob/feat/adr-0001/docs/architecture/decisions/libaktualizr.png)

This is NOT a class diagram of the current implementation, but rather logical blocks representing the main libaktualizr subsystems. The proposal is to implement the exception classes accordingly.

On the lower level are classes that interact with the operating system ether directly, or via libraries such as libcurl, libsodium, libsqlite3 etc: Crypto, Http and Storage. They must wrap all calls to the external libraries and produce an exception in case of an error.

Those classes are used by the higher level classes which provide such services as metadata handling, downloading and installing updates, and sending reports to the backend. Higher level classes must generate exceptions only in case of an error directly related to the logic of the class. In other words, if downloading of the metadata fails due to the broken network connection, exception should be generated by the Http class and transparently passed up the calling chain by the UptaneClient class. Another example is that the lack of disk space should be reported by Storage and not Package Manager.

Aktualizr class acts mostly as a "glue" class and should not generate many exceptions on its own. All other exception classes, however should be subclassed from it.

## Consequences

Implementing this model will likely require significant amount of refactoring.
