= Aktualizr Debugging Tips

== Running Aktualizr in development

The `sota_local.toml` configuration file sets the package manager to `PackageManagerFake`, which allows the installation process to be tested locally:

    # From the build directory
    mkdir sota-prov
    src/aktualizr_primary/aktualizr --config ../config/sota_local.toml

For VS code, there is a `launch.json` provided in the `.vscode` directory.  This assumes that the cmake build directory is `build`.

== Dumping information about SSL Certificates

    openssl s_client -state -debug -connect d3db2ce3-848b-4ca1-bd61-f76354601371.tcpgw.prod01.advancedtelematic.com:8000 -key bootstrap_pkey.pem -cert bootstrap_cert.pem -CAfile bootstrap_ca.pem   -servername d3db2ce3-848b-4ca1-bd61-f76354601371.tcpgw.prod01.advancedtelematic.com


    openssl x509 -in phil.p12.pem -text -noout

== Creating a temporary OSTree environment

    ostree admin os-init --sysroot /tmp/sysroot myos
    sudo ostree pull-local --repo /tmp/sysroot/ostree/repo/ /build-qemu/tmp/deploy/images/qemux86-64/ostree_repo/ -v
    sudo ostree admin deploy --sysroot /tmp/sysroot --os myos a818c3132783a652f913ea337ddc81d6900a3da618b0a0456953819d3d546e9b

== Running against a local test OSTree environment

Edit ../config/basic.toml to point `provision_path` to your automatic provisioning credentials, then from the build directory:

    wget https://s3.eu-central-1.amazonaws.com/pw-dropbox/ostree-sysroot.tar.gz
    tar -xf ostree-sysroot.tar.gz
    src/aktualizr_primary/aktualizr --config ../config/basic.toml

== Debuging secondaries update

To do it, You need to create temporary OSTree environment described above and add `sysroot` and `os` to your config file:

```
[ostree]
os = "myos"
sysroot = "/tmp/sysroot "

```

Then for each secondary you need to create a config file:

```
{
    "ecu_serial": "Your secondary serial",
    "ecu_hardware_id": "Your secondary hardware id",
    "ecu_private_key": "/tmp/priv.key",
    "ecu_public_key": "/tmp/pub.key",
    "firmware_path": "/firmware.txt"
}
```

Then, save them as `.json` files in a common directory.

Now You are ready to run aktualizr:

`./aktualizr -c config.toml --secondary-config secondaries_dir`

This will create needed keys and register Your secondaries. But currently You cannot shcedule updates
for secondaries because of it is not implemented in UI. So You have 2 options, You can change the ecu_serial
for Your secondary to primaries ecu_serial. By default it is located in ${certificates_directory}/primary_ecu_serial.

The second option is to use the following script to schedule your updates for the secondaries:
```
# We need the csrf-token and the cookies so that we can proxy via ci-app
# These needs to be filled in
CSRF_TOKEN=""
COOKIE=""
# The device we will target
DEVICE=""

# We will create a multi target update, though only targeting one thing
ECU_HARDWARE="qemux86-64" # hardware of the ecu to target
TARGET="target"           # the filepath of target
HASH="ea5fb32a7a43f081de0abe11528d7dee41cf2f36c13b66308b9b69d83f4dbd11" # the hash of the target
TARGET_LENGTH="130"       # the size of the target


# This command will create the update (but not schedule it anywhere)
MTU_UPDATE=$(http POST 'https://app.atsgarage.com/api/v1/multi_target_updates' Csrf-Token:"$CSRF_TOKEN" Cookie:"$COOKIE" targets:="{\"$ECU_HARDWARE\": {\"to\": {\"target\": \"$TARGET\", \"checksum\": {\"method\": \"sha256\", \"hash\":\"$HASH\"}, \"targetLength\": $TARGET_LENGTH}}}" | tr -d '"')
echo "The mtu-update is: $MTU_UPDATE"

# Schedule the update on the device
http PUT "https://app.atsgarage.com/api/v1/admin/devices/$DEVICE/multi_target_update/$MTU_UPDATE" Csrf-Token:"$CSRF_TOKEN" Cookie:"$COOKIE"


```

== Inspect stored info with aktualizr-info

To get information stored in data storage, could be used aktualizr-info utility.
By default, without any commandline arguments this utility displays only basic information including storage type, device ID, primary ECU serial and hardware ID and provisioning status.
Additional information can be requested with the following command line parameters:

```
  --tls-creds				Output root CA certificate, client certificate and client private key
  --ecu-keys				Output UPTANE keys for primary ECU
  --images-root                         Outputs root.json from images repo
  --images-target                       Outputs targets.json from images repo
  --director-root                       Outputs root.json from director repo
  --director-target                     Outputs targets.json from director repo
```

If You didn't specify the config file, the latest used with aktualizr config will be used.
Otherwise You could specify config file with `-c` commandline argument.

== Valgrind and gdb

If the target application or test is running under valgrind, then gdb can still be connected to the process without stopping it.  First run `vgdb --port=2159` in a different shell on the same machine, then connect to it using `target remote localhost:2159` in gdb

==  Dumping SSL encrypted traffic

First fetch and build sslkeylog from https://github.com/cajun-rat/sslkeylog

Next copy aktualizr.service to /etc/systemd/system/aktualizr.service.
This will override the packages default config.

Now modify `/etc/systemd/system/aktualizr.service` and add the following lines:

```
Environment=SSLKEYLOGFILE=/var/sota/premaster.txt
Environment=LD_PRELOAD=/usr/lib/libsslkeylog.so
```

Reload the config and restart

```
# systemctl daemon-reload
# systemctl restart aktualizr
```

The symmetric SSL keys will be logged in `/var/sota/premaster.txt`

Now capture a packet dump with tcpdump

```
sudo tcpdump tcp port 443 -w upload.pcap
```

Fetch both of these down. In wireshark preferences set ssl.keylog_file to point to premaster.txt. If your https traffic not on port 443, then add the port to http.ssl.port. Now open upload.pcap.

== Serve repo generated by aktualizr-repo

aktualizr can be tested against a dummy repository containing fake images

First, generate a repository using `aktualizr-repo` command:

    `aktualizr-repo generate repo_dir`

Then, serve the generated directory using a web server.

Here is an example configuration for nginx:

```
server {
    listen 80;
    listen [::]:80;
    server_name localhost;

    location / {
        try_files  $request_uri $request_uri;
    }
    location /director/manifest {
        try_files  $request_uri $request_uri;
        dav_methods  PUT;
    }

    root repo_dir/repo;
}
```

== Inject faults

See link:./fault-injection.adoc[fault-injection.adoc]

== Developing and debugging with an OpenEmbedded system

By default OpenEmbedded builds fixed versions of software from a VCS using bitbake recipes. When developing Aktualizr itself it is useful to have a quicker edit-compile-run cycle and access to a debugger. The following steps will use OpenEmbedded to create a cross-compilation environment, then build inside that.

1. Add the following to local.conf:
+
----
TOOLCHAIN_HOST_TASK_append = " nativesdk-cmake "
----

2. Build the SDK:
+
----
bitbake -c populate_sdk core-image-minimal
----

3. That will create a self-extracting installer that can be copied to your development machine. Install it by executing this script (or a similarly-named one, depending on your environment):
+
----
./tmp/deploy/sdk/poky-sota-glibc-x86_64-core-image-minimal-core2-64-toolchain-2.2.2.sh
----

4. Execute this script (or something similar, depending on where you installed it) to update the environment to point to the cross compilers:
+
----
. /opt/poky-sota/2.2.2/environment-setup-core2-64-poky-linux
----
+
You may want to verify that `which cmake` returns something like this:
+
----
/opt/poky-sota/2.2.2/sysroots/x86_64-pokysdk-linux/usr/bin/cmake
----

5. Create a cmake build directory for this cross-compile:
+
----
mkdir build-cross
cd build-cross
cmake .. <options>
make aktualizr
----

The compiled 'aktualizr' executable can be copied to the remote system and run.

Aktualizr can be debugged remotely by exposing a port from the VM to development machine (the --gdb option to the https://github.com/advancedtelematic/meta-updater/blob/master/scripts/run-qemu-ota[run-qemu-ota script] in https://github.com/advancedtelematic/meta-updater[meta-updater] does this), then:

.On the target:
----
gdbserver 0.0.0.0:2159 ./aktualizr --config /usr/lib/sota/sota.toml --loglevel 0
----

.On the host:
----
$ gdb aktualizr
(gdb) target remote localhost:2159
----

In CLion the remote debugger is configured as follows:

image:clion-debugger.png[CLion GDB configuration]

It is also possible to run it inside valgrind:

.On the target:
----
valgrind --vgdb=yes --vgdb-error=0 ./aktualizr --config /usr/lib/sota/sota.toml
vgdb --port=2159
----

Then connect the debugger as usual.


